<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>L08 additional</title>
</head>
<body>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fight Club</title>
</head>
<body>
<div id="content"></div>
<h1>Правила бойцовского клуба</h1>
<div id="wrap">
    <div class="rules rule1">
        <h2>Первое правило Бойцовского клуба.</h2>
        <p>Никому не рассказывать о Бойцовском клубе.</p>
    </div>
    <div class="rules rule2">
        <h2>Второе правило Бойцовского клуба.</h2>
        <p>Никогда никому не рассказывать о Бойцовском клубе.</p>
    </div>
    <div class="rules rule3">
        <h2>Третье правило Бойцовского клуба.</h2>
        <p>В схватке участвуют только двое.</p>
    </div>
    <div class="rules rule4">
        <h2>Четвертое правило Бойцовского клуба.</h2>
        <p>Не более одного поединка за один раз.</p>
    </div>

    <div class="rules rule5">
        <h2>Пятое правило Бойцовского клуба.</h2>
        <p>Бойцы сражаются без обуви и голые по пояс.</p>
    </div>
    <div class="rules rule6">
        <h2>Шестое правило Бойцовского клуба.</h2>
        <p>Поединок продолжается столько, сколько потребуется.</p>
    </div>
    <div class="rules rule7">
        <h2>Седьмое правило Бойцовского клуба.</h2>
        <p>Если противник потерял сознание или делает вид, что потерял, или говорит «Хватит» — поединок
            окончен.</p>
    </div>
    <div class="rules rule8">
        <h2>Восьмое и последнее правило Бойцовского клуба.</h2>
        <p>Новичок обязан принять бой.</p>
    </div>
</div>

<script>
    // написати рекурсивну функцію, яка збирає всі назви класів з файлу rules.html в окремий масив. масив вивести в консоль

    // console.log(document.classList);    //undefined
    // console.log(document.body.classList);   //DOMTokenList[value: '']
    // console.log(document.querySelectorAll('[class]')); //array
    //=================


    //не рекурсивний спосіб

    // let allClasses = ()=> {
    //     let allClasses = [];
    //     let allElements = document.querySelectorAll('*');
    //     // console.log(allElements);
    //     for (var i = 0; i < allElements.length; i++) {
    //         var classes = allElements[i].className.toString().split(/\s+/);
    //         for (var j = 0; j < classes.length; j++) {
    //             var cls = classes[j];
    //             if (cls && allClasses.indexOf(cls) === -1)
    //                 allClasses.push(cls);
    //         }
    //     }
    //     return allClasses
    // }
    // console.log(allClasses());


    //https://stackoverflow.com/questions/2712136/how-do-i-make-this-loop-all-children-recursively

    // function searchTree(element, matchingTitle){
    //     if(element.title === matchingTitle){
    //         return element;
    //     }else if (element.children != null){
    //         var i;
    //         var result = null;
    //         for(i=0; result === null && i < element.children.length; i++){
    //             result = searchTree(element.children[i], matchingTitle);
    //         }
    //         return result;
    //     }
    //     return null;
    // }
    //
    // var element = data[0];
    // var result = searchTree(element, 'randomNode_1');


    // console.log(document.childNodes);
    let allClasses = [];
    let iter = 0;

    // let recursionClassSearch = function () {
    //     if (arguments.length === 0) {
    //         for (let node of document.childNodes) {
    //             if (node.classList.length !== 0) {
    //                 for (let classListElement of node.classList) {
    //                     allClasses = allClasses.append(classListElement + ' ');
    //                 }
    //             }
    //             if (node.childNodes.length !== 0) {
    //                 for (let childNode of node.childNodes) {
    //                     recursionClassSearch(childNode);
    //                 }
    //             }
    //         }
    //     } else {
    //         for (let node of arguments[0].childNodes) {
    //             if (node.classList.length !== 0) {
    //                 for (let classListElement of node.classList) {
    //                     allClasses = allClasses.append(classListElement + ' ');
    //                 }
    //             }
    //             if (node.childNodes.length !== 0) {
    //                 for (let childNode of node.childNodes) {
    //                     recursionClassSearch(childNode);
    //                 }
    //             }
    //         }
    //     }
    // }

    let recursionClassSearch = function () {
        if (arguments.length === 0) {
            if (document.classList) {
                //console.log('\n\n'+(arguments[0]+'').replace('[','').replace(' HTML',': ').replace('Element]',''));
                // console.log(arguments[0].classList);
                for (let classListElement of document.classList) {
                    if (!allClasses.includes(classListElement)) {
                        allClasses[iter] = classListElement;
                        iter++;
                    }
                }
            }
            iter = 0;
            for (let i = 0; i < document.childNodes.length; i++) {
                // if (document.classList) {
                //     console.log(arguments[0].classList);
                // }
                let node = document.childNodes[i];
                // if (node.classList) {
                //     console.log(node);
                // }
                // console.log('length:  ' + node.childNodes.length);
                if (node.childNodes.length !== 0) {
                    for (let childNode of node.childNodes) {
                        recursionClassSearch(childNode);
                    }
                }
            }
        } else {
            if (arguments[0].classList) {
                //console.log('\n\n'+(arguments[0]+'').replace('[','').replace(' HTML',': ').replace('Element]',''));
                // console.log(arguments[0].classList);
                for (let classListElement of arguments[0].classList) {
                    if (!allClasses.includes(classListElement)) {
                        allClasses[iter] = classListElement;
                        iter++;
                    }
                }
            }

            for (let i = 0; i < arguments[0].childNodes.length; i++) {
                let node = arguments[0].childNodes[i];
                // console.log(i);
                // console.log(node);
                // if (arguments[0].childNodes[i].classList) {
                //     // console.log(arguments[0].childNodes[i].classList);
                // }
                //console.log('length:  '+node.childNodes.length);
                if (node.childNodes.length !== 0) {
                    // console.log(node.childNodes);
                    for (let childNode of node.childNodes) {
                        recursionClassSearch(childNode);
                    }
                }
            }
        }
    }

    //debugger
    recursionClassSearch();
    console.log(allClasses);


</script>
</body>
</html>
</body>
</html>